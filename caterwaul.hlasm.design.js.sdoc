High-level assembler design | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
The high-level assembler is designed to be a more usable way to write assembly programs. It features a reasonably consistent C-like base layer but ends up being significantly more expressive
than C due to the fact that it is used in a first-class context; that is, Javascript provides abstraction over code generation and Caterwaul provides quotation to minimize overhead.

This assembler is significantly different from other assemblers in that it does register allocation, optimization, CPS-conversion, and instruction interleaving. It does this by exposing a
parallel interface; rather than writing a single sequential program, you specify multiple independent dataflows that can execute simultaneously (or in any order), and the assembler merges them
together to maximize processor throughput. Because x86 processor throughput is a non-trivial optimization problem, the explicit separation of data paths allows the assembler to emit several
different alternatives and choose the one that runs fastest rather than using a predictive and/or heuristic approach.

Basic blocks and parallelism.
Basic blocks differ from data-independent streams in that they each end in a link to another basic block. In this sense they are lower-level than data streams, though because of the coupling
between control flow and data flow they aren't represented this way. Rather, each basic block is separated into one or more data-independent execution paths, and the block is compiled into an
interleaved code segment at runtime. For example, here is a logical view of basic blocks and data streams:

|   basic block 1      basic block 2      basic block 3
  +---------------+  +---------------+  +---------------+
  | data stream 1 |  | data stream 1 |  | data stream 1 |
  +---------------+  +---------------+  +---------------+
  +---------------+
  | data stream 2 |
  +---------------+

And here is how they would be emitted (where dXiY is instruction Y of data stream X):

| d1i1 d2i1 d2i2 d1i2 ...       ; basic block 1
  d1i1 d1i2 ... d1in            ; basic block 2
  d1i1 d1i2 ... d1in            ; basic block 3

The data stream model is particularly advantageous for EPIC architectures such as Itanium. Arbitrarily many data streams can be assigned to a basic block; the more the merrier barring
inefficiencies in the block compiler.

Instruction set.
I'm going mostly object-oriented for this design. Data streams and blocks share an interface; each provides a sequence of assembled instructions. The instruction set, however, is fixed; these
instructions are supported:

| alloc :: i64 -> i64
  free  :: i64 -> i64
  {add,sub,and,or,xor,rol,ror,shl,shr}i :: (i64,  i64)  -> i64
  {add,sub,and,or,xor,abs,mul,div}[s]f  :: ([s]f, [s]f) -> [s]f
  {not,neg,one}i :: i64 -> i64
  {mul}[u]i      :: (i64, i64) -> i64
  call/cc        :: (i64, *) -> *
  get            :: i64 -> *
  set            :: (i64, *) -> *

Here, i64 is a 64-bit signed or unsigned integer (signedness is determined by context). sf is a short-float (32 bits) and f is a double. Numeric types are never implicitly converted, since
they aren't reified in any way. To convert between them:

| cisf :: i64 -> sf
  cif  :: i64 -> f
  cfi  :: f  -> i64
  csfi :: sf -> i64

  Platform-specific syscall interfaces.
  Not all platforms use the same strategy for syscalls, and I'm not going to try to unify that at this level of abstraction. (Which is acceptable in part because the syscall numbers vary by
  platform anyway.) Each syscall instruction is prefixed by its architecture and OS:

  | l32sys :: (i64, i64, i64) -> i64
    l64sys :: (i64, i64, i64) -> i64

  Predication prefixes.
  The x86 instruction set is a pathological example of design; more intelligent folks elsewhere had the sense to implement proper predication. For both ARM and IA64 instruction sets, for
  example, each instruction can be predicated by a branch-register selector rather than doing a separate jump. The caterwaul assembler follows that convention:

  | cmpi  :: (i64, i64) -> i64
    cmpsf :: (sf,  sf)  -> i64
    cmpf  :: (f,   f)   -> i64
    pr :: i64 -> (a -> b, b) -> a -> b
    p  :: i64 -> (a -> b) -> i64

  The pr instruction always returns a b, and the p instruction returns the conditional bits.

Assembly semantics.
The assembler is modeled as a functional language, which may seem like an odd way to do it. The assembly process looks like this:

| 1. CPS-convert.
  2. Identify control-flow divergence and variant continuations; these become basic blocks.
  3. Perform basic lifecycle analysis to determine value extents.
  4. Delegate register/memory allocation to an architecture-specific backend.
