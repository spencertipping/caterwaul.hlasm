// C++ backend for high-level assembler | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module exists to generate C++ from high-level assembly definitions. It wouldn't be used much in production; it's primarily useful for me to debug stuff. Something useful may end up coming
// out of it though. If you let a Javascript program run in interpreted mode for some time, you can take the collected traces and emit specialized code for them. It's theoretically possible to
// leverage this to generate performant C++ for a given Javascript workflow.

// To support tail calls, the code generated by this backend is incredibly gnarly and bizarre. It should be reasonably fast though.

// Input data.
// The format for incoming data is very simple. It's a hash from global name to bytecode or array of bytes. All we have to do is generate C++ to emulate the bytecode in the context of those
// globals. Naturally the C++ generated by this backend is type-erased.

  caterwaul.tconfiguration('std seq continuation', 'hlasm.cpp', function () {
    this.namespace('hlasm').cpp = translate,
    where*[translate(globals, opts)  = l*[os       = opts || {},
                                          derived  = seq[sp[globals] *[compile(_[0], _[1], os)] /[caterwaul.util.merge(_, _0)]], prelude = prerequisites(derived) + ';\n\n',
                                          compiled = seq[~sk[derived].sort() *[[_, derived[_]]]
                                                         -[['// Begin #{_[0]}: #{_[1].source.replace(/\n/g, "")}',
                                                            '#{_[0]}:' + (os.trace ?
                                                              'fprintf(stderr, "\\n%""s %""d %""s", "#{_[0]}", &&#{_[0]} - (long long)&main, "#{_[1].source.replace(/\n/g, "")}");' : ''),
                                                            _[1].generated.join(';\n') + ';', '// End #{_[0]}\n']]].join('\n')] in
                                       prelude + 'int main() {\n*--c = &&exit;\ngoto main;\nexit:\nreturn *d;\n\n#{compiled}\n}',

           gs                        = l[c = 0] in fn_['g#{++c}'],
           prerequisites(globals)    = ['#include<stdio.h>', '#define DATA_S 1048576', '#define CODE_S 32768',
                                        'typedef long long e;', 'typedef double f;', 'static e data[DATA_S];', 'static e code[CODE_S];', 'static e dtmp[DATA_S];',
                                        'static e *d = data + DATA_S;', 'static e *D = dtmp;', 'static e *c = code + CODE_S;', 'static e tmp;',
                                        'static void pr_int(long long x) {printf("%lld\\n", x);}', 'static void pr_float(double x) {printf("%f\\n", x);}',
                                        'static void *globals[] = {&pr_int, &pr_float};', 'static void* gs = globals + 2;'].join('\n'),

           bytecode_translations     = {} /se.ts[
             seq[~'0123456789' *![ts[_]() = '*d *= 10; *d += #{_}']], seq[sp[{a:'+', b:'-', c:'*', '&':'&', '|':'|', '^':'^'}] *![ts[_[0]]() = 'd[1] #{_[1]}= *d++']],
             ts.d() = gs() /re['e #{_} = d[0]; d[0] = d[1] % #{_}, d[1] /= #{_}'], seq[sp[{A:'+', B:'-', C:'*', D:'/'}] *![ts[_[0]]() = '((f*)d)[1] #{_[1]}= *(f*)d++']],
             seq[sp[{n:'-', '!':'!', '~':'~'}] *![ts[_[0]]() = '*d = #{_[1]}*d']], ts.e() = '++*d', ts.E() = '--*d', ts.n() = '*d = -*d', ts.N() = '*(*f)d = -*(*f)d',
             ts['<']() = 'd[1] <<= *d++', ts['>']() = 'd[1] >>= *d++', ts['_']() = '*--d = gs', ts[':']() = '*d = gs + *d',

             ts.i() = gs() /re['*--c = &&#{_}; goto **d++; #{_}:'], ts.j() = 'goto **d++', ts[']']() = 'goto **c++', ts.m() = '*d = malloc(*d)', ts.M() = 'free(*d++)',

             ts.l() = 'tmp = *d < *++d; *d = tmp', ts.L() = 'tmp = *(f*)d < *(f*)++d; *d = tmp', ts.k() = '*--d = 0', ts.K() = '*--d = 1', ts.t() = '*--d = 2', ts.T() = '*--d = 3',
             ts.s() = '*d = d[*d + 1]', ts.S() = 'd[*d + 1] = *d', ts.v() = '*(*f)d = *d', ts.V() = '*d = *(*f)d', ts.w() = 'tmp = *d; *d = d[1]; d[1] = tmp',
             ts.z() = gs() /re['tmp = *d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d = *--D'],
             ts.Z() = gs() /re['tmp = *d++; *D++=*d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d=*--D; *--d=*--D'],

             ts['.']() = '*--d = d[1]', ts[',']() = '++d', ts['+']() = 'd += *d', ts['-']() = 'd -= *d', ts['@']() = '*--d = d', ts['#']() = 'd = *d', ts['$']() = '*--d = c',
             ts['%']() = 'c = *d++', ts['?']() = gs() /re['*--c = &&#{_}; goto **((d += 3) - 2 - !d[-1]); #{_}:'], ts['/']() = 'goto **((d += 3) - 2 - !d[-1])',
                                     ts['f']() = gs() /re['d += 2; if (d[-1]) {*--c = #{_}; goto *d[-2];} #{_}:'], ts['F']() = 'd += 2; if (d[-1]) goto *d[-2];'],

           compile(n, code, opts) = l*[ns = seq[~[]], cs = seq[~[]], ss = seq[~[]], globals = {},
                                       trace_for(opts, i, x) = opts.trace ? 'fprintf(stderr, "\\n%""4s", "#{x}"); #{i}; ' +
                                                                            'fprintf(stderr, "%""10d|s%""10d|c%""20lld|v%""20lld|dv%""20lf|V", ' +
                                                                              'data + DATA_S - d, code + CODE_S - c, *d, *d - (long long)&main, *d)' : i,
                                       encode(x) = bytecode_translations[x] /re['/* #{x} */ #{trace_for(opts, _ ? _() : "", x)}'],
                                       enter(n) = globals /se[cs.length && cs[cs.length - 1].push('/* [ */ *--d = &&#{n}'), ns.push(n), cs.push([]), ss.push([])],
                                       leave()  = globals /se[_[ns.pop()] = {generated: cs.pop() /se[_.push(encode(']'))], source: ss.pop().join('')}],
                                       c(i, cc) = code.charAt(i) /re[_ === '[' ? enter(gs()) /se[r()] : _ === ']' ? r() /re[leave()] : cs[cs.length - 1].push(encode(_)) /se[r()],
                                                                     where[r() = seq[ss *!s[s.push(_)]]]]
                                                                 /re[i < code.length - 1 ? call/tail[c(i + 1, cc)] : cc(leave())]] in
                                     call/cc[fn[cc][enter(n), call/tail[c(0, cc)]]]]});

// Generated by SDoc 
