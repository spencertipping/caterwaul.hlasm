// C++ backend for high-level assembler | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module exists to generate C++ from high-level assembly definitions. It wouldn't be used much in production; it's primarily useful for me to debug stuff. Something useful may end up coming
// out of it though. If you let a Javascript program run in interpreted mode for some time, you can take the collected traces and emit specialized code for them. It's theoretically possible to
// leverage this to generate performant C++ for a given Javascript workflow.

// To support tail calls, the code generated by this backend is incredibly gnarly and bizarre. It should be reasonably fast though.

// Input data.
// The format for incoming data is very simple. It's a hash from global name to bytecode or array of bytes. All we have to do is generate C++ to emulate the bytecode in the context of those
// globals. Naturally the C++ generated by this backend is type-erased.

  caterwaul.tconfiguration('std seq continuation', 'hlasm.cpp', function () {
    this.namespace('hlasm').cpp = translate,
    where*[translate(globals, opts)  = l*[os       = opts || {},
                                          derived  = seq[sp[globals] *[compile(_[0], _[1], os)] /[caterwaul.util.merge(_, _0)]], prelude = prerequisites(derived),
                                          compiled = seq[~sk[derived].sort() *[[_, derived[_]]]
                                                         -[['// Begin #{_[0]}: #{_[1].source.replace(/\n/g, "")}',
                                                            '#{_[0]}:' + (os.trace ?
                                                              'fprintf(stderr, "\\n%""s %""d %""s", "#{_[0]}", &&#{_[0]} - (long long)&main, "#{_[1].source.replace(/\n/g, "")}");' : ''),
                                                            _[1].generated.join(';\n') + ';', '// End #{_[0]}\n']]].join('\n')] in
                                       prelude + '\n\nint main() {\n\n#{main_setup(globals, os)}\n\n#{compiled}\n}',

           gs                        = l[c = 0] in fn_['g#{++c}'],
           main_setup(globals, opts) = ['e globals[] = {&&sleep_ms, &&pr_stacks, &&pr_float, &&pr_int, #{seq[(0 >>>[_ + 1] <<[_ < 99]) *["NULL"]].join(", ")}, &&write_c' +
                                        (opts.layout ? seq[~opts.layout.split(/\s+/) *[', &&' + _]].join('') : '') + '};',
                                        'e* gs = globals + 104;', 'int i = 0;', 'e *j = 0;', '*--c = &&exit;', 'goto main;',
                                        'exit: return *d;', 'pr_int: printf("%""d\\n", *d++); goto **c++;', 'pr_float: printf("%f\\n", *d++); goto **c++;',
                                        'pr_stacks:',
                                        'fprintf(stderr, "\\n[data]\\n"); for(j = d; j < data + DATA_S; ++j) fprintf(stderr, "%""4d|i%""20d|v%""20d|dv%""20f|V\\n", j - d, *j, *j - (e)(&main), *j);',
                                        'fprintf(stderr, "[daux]\\n"); for(j = dtmp; j < D; ++j) fprintf(stderr, "%""4d|i%""20d|v%""20d|dv%""20f|V\\n", j - dtmp, *j, *j - (e)(&main), *j);',
                                        'fprintf(stderr, "[code]\\n"); for(j = c; j < code + CODE_S; ++j) fprintf(stderr, "%""4d|i%""20d|dv\\n", j - c, *j - (e)(&main));',
                                        'goto **c++;',
                                        'sleep_ms: usleep(*d++ * 1000); goto **c++;', 'std_call: (*(void(*)())d++)(); goto **c++;', 'write_c: putc((char) *d++, stdout); goto **c++;'].join('\n'),

           prerequisites(globals)    = ['#include<stdio.h>', '#include<unistd.h>', '#define DATA_S 1048576', '#define CODE_S 32768', '#define start(x) fprintf(stderr, "\\n%""8s", x)',
                                        '#define trace fprintf(stderr, "%""8d|x%""8d|s%""6d|c%""20lld|v%""20lld|dv%""20lf|V", ' +
                                                              'D - dtmp, data + DATA_S - d, code + CODE_S - c, *d, *d - (long long)&main, *d)',
                                        '', 'typedef long long e;', 'typedef double f;', 'static e data[DATA_S];', 'static e code[CODE_S];', 'static e dtmp[DATA_S];',
                                        'static e *d = data + DATA_S;', 'static e *D = dtmp;', 'static e *c = code + CODE_S;', 'static e tmp;'].join('\n'),

           bytecode_translations     = {} /se.ts[
             seq[~'0123456789' *![ts[_]() = '*d *= 10; *d += #{_}']], seq[sp[{a:'+', b:'-', c:'*', '&':'&', '|':'|', '^':'^'}] *![ts[_[0]]() = 'd[1] #{_[1]}= *d++']],
             ts.d() = gs() /re['e #{_} = d[0]; d[0] = d[1] % #{_}, d[1] /= #{_}'], seq[sp[{A:'+', B:'-', C:'*', D:'/'}] *![ts[_[0]]() = '((f*)d)[1] #{_[1]}= *(f*)d++']],
             seq[sp[{n:'-', '!':'!', '~':'~'}] *![ts[_[0]]() = '*d = #{_[1]}*d']], ts.e() = '++*d', ts.E() = '--*d', ts.n() = '*d = -*d', ts.N() = '*(*f)d = -*(*f)d',
             ts['<']() = 'd[1] <<= *d++', ts['>']() = 'd[1] >>= *d++', ts['_']() = '*--d = gs', ts['*']() = '*d = *(e*)(*d)', ts['=']() = '*d[1] = *d; ++d',

             ts.r() = gs() /re['++d; if (*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:'], ts.R() = gs() /re['++d; if (!*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:'],

             ts.g() = gs() /re['*--c = &&#{_}; goto *gs[*d++]; #{_}:'], ts.G() = 'goto *gs[*d++]', 
             ts.i() = gs() /re['*--c = &&#{_}; goto **d++; #{_}:'], ts.I() = 'goto **d++', ts[']']() = 'goto **c++', ts.m() = '*d = malloc(*d)', ts.M() = 'free(*d++)',
             ts.y() = l[e = gs(), r = gs()] in '*D++ = *d++; *--c = &&#{e}; #{r}: *--d = &&#{r}; goto *D[-1]; #{e}: --D',
             ts.Y() = gs() /re['*D++ = *d++; *D++ = *d++; for (*D++ = 0; D[-1] < D[-3]; ++D[-1]) {*--c = &&#{_}; *--d = D[-1]; goto *D[-2]; #{_}:;} D -= 3'],

             ts.l() = 'tmp = *d < *++d; *d = tmp', ts.L() = 'tmp = *(f*)d < *(f*)++d; *d = tmp', ts.k() = '*--d = 0', ts.K() = '*--d = 1', ts.t() = '*--d = 2', ts.T() = '*--d = 3',
             ts.s() = '*d = d[*d + 1]', ts.S() = 'd[*d] = d[1]; d += 2', ts.v() = '*(f*)d = (f)*d', ts.V() = '*d = (e)*(f*)d', ts.w() = 'tmp = *d; *d = d[1]; d[1] = tmp',
             ts.z() = gs() /re['tmp = *d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d = *--D'],
             ts.Z() = gs() /re['d += 2; for (i = 0; i < d[-2]; ++i) *D++=d[i]; tmp=d[-1]; d += *D++=i; *--c = &&#{_}; goto *tmp; #{_}: for (i = *--D; i > 0; --i) *--d = *--D'],

             ts['.']() = '*--d = d[1]', ts[',']() = '++d', ts['+']() = 'd += *d + 1', ts['-']() = 'd -= *d - 1', ts['@']() = '*--d = d', ts['#']() = 'd = *d', ts['$']() = '*--d = c',
             ts['%']() = 'c = *d++', ts['?']() = gs() /re['*--c = &&#{_}; goto **((d += 3) - 2 - !d[-1]); #{_}:'], ts['/']() = 'goto **((d += 3) - 2 - !d[-1])',
                                     ts['f']() = gs() /re['d += 2; if (d[-1]) {*--c = #{_}; goto *d[-2];} #{_}:'], ts['F']() = 'd += 2; if (d[-1]) goto *d[-2]'],

           compile(n, code, opts) = l*[ns = seq[~[]], cs = seq[~[]], ss = seq[~[]], globals = {}, trace_for(opts, i, x) = opts.trace ? 'start("#{x}"); #{i}; trace' : i,
                                       encode(x) = bytecode_translations[x] /re['/* #{x} */ #{trace_for(opts, _ ? _() : "", x)}'],
                                       enter(n) = globals /se[cs.length && cs[cs.length - 1].push('/* [ */ *--d = &&#{n}'), ns.push(n), cs.push([]), ss.push([])],
                                       leave()  = globals /se[_[ns.pop()] = {generated: cs.pop() /se[_.push(encode(']'))], source: ss.pop().join('')}],
                                       c(i, cc) = code.charAt(i) /re[_ === '[' ? enter(gs()) /se[r()] : _ === ']' ? r() /re[leave()] : cs[cs.length - 1].push(encode(_)) /se[r()],
                                                                     where[r() = seq[ss *!s[s.push(_)]]]]
                                                                 /re[i < code.length - 1 ? call/tail[c(i + 1, cc)] : cc(leave())]] in
                                     call/cc[fn[cc][enter(n), call/tail[c(0, cc)]]]]});

// Generated by SDoc 
