C++ backend for high-level assembler | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This module exists to generate C++ from high-level assembly definitions. It wouldn't be used much in production; it's primarily useful for me to debug stuff. Something useful may end up coming
out of it though. If you let a Javascript program run in interpreted mode for some time, you can take the collected traces and emit specialized code for them. It's theoretically possible to
leverage this to generate performant C++ for a given Javascript workflow.

To support tail calls, the code generated by this backend is incredibly gnarly and bizarre. It should be reasonably fast though.

Input data.
The format for incoming data is very simple. It's a hash from global name to bytecode or array of bytes. All we have to do is generate C++ to emulate the bytecode in the context of those
globals. Naturally the C++ generated by this backend is type-erased.

  caterwaul.tconfiguration('std seq continuation', 'hlasm.cpp', function () {
    this.namespace('hlasm').cpp = translate,
    where*[translate(globals)        = '// Global setup:\n#{prerequisites(globals)}\n// Main code:\nint main() {\n#{seq[sp[globals] *[global(_[0], _[1])]].join("\n")}}',

           slice(x)                  = Array.prototype.slice.call(x),
           statements()              = seq[~arguments *[_ instanceof Array ? statements.apply(this, slice(_)) : _] *['  #{_};']].join('\n'),
           prerequisites(globals)    = statements('typedef long long e', 'typedef double f', 'static e data[1048576]', 'static e code[32768]', 'static e dtmp[1048576]',
                                                  'static e *d = data + 1048576', 'static e *D = dtmp', 'static e *c = code + 32768', 'static e tmp'),

           global(name, v)           = v instanceof Array ? compile_constant(name, v) : statements.apply(this, slice(compile_bytecode(name, seq[~v]))),

           bytecode_translations     = {} /se.ts[
             seq[~'0123456789' *![ts[_]() = '*d *= 10; *d += #{_}']], seq[sp[{a:'+', b:'-', c:'*', '&':'&', '|':'|', '^':'^'}] *![ts[_[0]]() = 'd[1] #{_[1]}= *d++']],
             ts.d() = gs() /re['e #{_} = d[0]; d[0] = d[1] % #{_}, d[1] /= #{_}'], seq[sp[{A:'+', B:'-', C:'*', D:'/'}] *![ts[_[0]]() = '((f*)d)[1] #{_[1]}= *(f*)d++']],
             seq[sp[{n:'-', '!':'!', '~':'~'}] *![ts[_[0]]() = '*d = #{_[1]}*d']], ts.e() = '++*d', ts.E() = '--*d', ts.n() = '*d = -*d', ts.N() = '*(*f)d = -*(*f)d',
             ts['<']() = 'd[1] <<= *d++', ts['>']() = 'd[1] >>= *d++',

             ts.i() = gs() /re['*--c = &&#{_}; goto *d; #{_}:'], ts.j() = 'goto *d',

             ts.l() = 'tmp = *d < *++d; *d = tmp', ts.L() = 'tmp = *(f*)d < *(f*)++d; *d = tmp', ts.k() = '*--d = 0', ts.K() = '*--d = 1', ts.t() = '*--d = 2', ts.T() = '*--d = 3',
             ts.s() = '*d = d[*d + 1]', ts.S() = 'd[*d + 1] = *d', ts.v() = '*(*f)d = *d', ts.V() = '*d = *(*f)d', ts.w() = 'tmp = *d, *d = d[1], d[1] = tmp',
             ts.z() = gs() /re['tmp = *d++; *D++=*d++; *--c = &&#{_}; #{_}: *--d = *--D'], ts.Z() = gs() /re['tmp = *d++; *D++=*d++; *D++=*d++; *--c = &&#{_}; #{_}: *--d=*--D; *--d=*--D'],

             ts['.']() = '*--d = d[1]', ts[',']() = '++d', ts['+']() = 'd += *d', ts['-']() = 'd -= *d', ts['@']() = '*--d = d', ts['#']() = 'd = *d', ts['$']() = '*--d = c',
             ts['%']() = 'c = *d++', ts['?']() = gs() /re['*--c = &&#{_}; goto *((d += 3) - 2 - !d[2]); #{_}:'],  ts['/']() = 'goto *((d += 3) - 2 - !d[2])',
                                     ts['f']() = gs() /re['d += 2; if (d[-1]) {*--c = #{_}; goto d[-2];} #{_}:'], ts['F']() = 'd += 2; if (d[-1]) goto d[-2];',
             where*[gs = caterwaul.gensym]],

           compile_bytecode(name, vs, vi_prime) =
             l*[result = seq[~[]], vi = vi_prime || {n: 0}, next() = vs[vi.n++], emit = result/mb/push,
                compile_next() = next() /re.c[c === ']' || vi.n > vs.length ? emit('goto *c++') :
                                              c === '[' ? l[gs = caterwaul.gensym(), _ = ++vi.n] in emit('*--d = &&#{gs}', compile_bytecode(gs, vs, vi)) /se[compile_next()] :
                                                          bytecode_translations[c] /re[_ && _()] /re[_ && emit(_), compile_next()]]] in emit('#{name}: ') /se[compile_next()] /re[result]]});
