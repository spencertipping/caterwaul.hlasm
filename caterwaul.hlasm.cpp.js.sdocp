sdocp('caterwaul.hlasm.cpp.js.sdoc', 'C++ backend for high-level assembler | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis module exists to generate C++ from high-level assembly definitions. It wouldn\'t be used much in production; it\'s primarily useful for me to debug stuff. Something useful may end up coming\nout of it though. If you let a Javascript program run in interpreted mode for some time, you can take the collected traces and emit specialized code for them. It\'s theoretically possible to\nleverage this to generate performant C++ for a given Javascript workflow.\n\nTo support tail calls, the code generated by this backend is incredibly gnarly and bizarre. It should be reasonably fast though.\n\nInput data.\nThe format for incoming data is very simple. It\'s a hash from global name to bytecode or array of bytes. All we have to do is generate C++ to emulate the bytecode in the context of those\nglobals. Naturally the C++ generated by this backend is type-erased.\n\n  caterwaul.tconfiguration(\'std seq continuation\', \'hlasm.cpp\', function () {\n    this.namespace(\'hlasm\').cpp = translate,\n    where*[translate(globals, opts)  = l*[os       = opts || {},\n                                          derived  = seq[sp[globals] *[compile(_[0], _[1], os)] /[caterwaul.util.merge(_, _0)]], prelude = prerequisites(derived),\n                                          compiled = seq[~sk[derived].sort() *[[_, derived[_]]]\n                                                         -[[\'// Begin #{_[0]}: #{_[1].source.replace(/\\n/g, "")}\',\n                                                            \'#{_[0]}:\' + (os.trace ?\n                                                              \'fprintf(stderr, "\\\\n%""s %""d %""s", "#{_[0]}", &&#{_[0]} - (long long)&main, "#{_[1].source.replace(/\\n/g, "")}");\' : \'\'),\n                                                            _[1].generated.join(\';\\n\') + \';\', \'// End #{_[0]}\\n\']]].join(\'\\n\')] in\n                                       prelude + \'\\n\\nint main() {\\n\\n#{main_setup(globals, os)}\\n\\n#{compiled}\\n}\',\n\n           gs                        = l[c = 0] in fn_[\'g#{++c}\'],\n           main_setup(globals, opts) = [\'static void* globals[] = {&&write_c, &&std_call, &&pr_float, &&pr_int#{opts.layout ? seq[~opts.layout.split(/\\s+/) *[", &&" + _]].join("") : ""}};\',\n                                        \'static void** gs = globals + 4;\',\n                                        \'*--c = &&exit;\', \'goto main;\', \'exit: return *d;\', \'pr_int: printf("%""d\\\\n", *d++); goto **c++;\', \'pr_float: printf("%f\\\\n", *d++); goto **c++;\',\n                                        \'std_call: (*(void(*)())d++)(); goto **c++;\', \'write_c: putc((char) *d++, stdout); goto **c++;\'].join(\'\\n\'),\n\n           prerequisites(globals)    = [\'#include<stdio.h>\', \'#define DATA_S 1048576\', \'#define CODE_S 32768\', \'#define start(x) fprintf(stderr, "\\\\n%""8s", x)\',\n                                        \'#define trace fprintf(stderr, "%""8d|x%""8d|s%""6d|c%""20lld|v%""20lld|dv%""20lf|V", \' +\n                                                              \'D - dtmp, data + DATA_S - d, code + CODE_S - c, *d, *d - (long long)&main, *d)\',\n                                        \'\', \'typedef long long e;\', \'typedef double f;\', \'static e data[DATA_S];\', \'static e code[CODE_S];\', \'static e dtmp[DATA_S];\',\n                                        \'static e *d = data + DATA_S;\', \'static e *D = dtmp;\', \'static e *c = code + CODE_S;\', \'static e tmp;\'].join(\'\\n\'),\n\n           bytecode_translations     = {} /se.ts[\n             seq[~\'0123456789\' *![ts[_]() = \'*d *= 10; *d += #{_}\']], seq[sp[{a:\'+\', b:\'-\', c:\'*\', \'&\':\'&\', \'|\':\'|\', \'^\':\'^\'}] *![ts[_[0]]() = \'d[1] #{_[1]}= *d++\']],\n             ts.d() = gs() /re[\'e #{_} = d[0]; d[0] = d[1] % #{_}, d[1] /= #{_}\'], seq[sp[{A:\'+\', B:\'-\', C:\'*\', D:\'/\'}] *![ts[_[0]]() = \'((f*)d)[1] #{_[1]}= *(f*)d++\']],\n             seq[sp[{n:\'-\', \'!\':\'!\', \'~\':\'~\'}] *![ts[_[0]]() = \'*d = #{_[1]}*d\']], ts.e() = \'++*d\', ts.E() = \'--*d\', ts.n() = \'*d = -*d\', ts.N() = \'*(*f)d = -*(*f)d\',\n             ts[\'<\']() = \'d[1] <<= *d++\', ts[\'>\']() = \'d[1] >>= *d++\', ts[\'_\']() = \'*--d = gs\', ts[\':\']() = \'*d = gs + *d\', ts[\'*\']() = \'*d = *(e*)(*d)\', ts[\'=\']() = \'*d[1] = *d; ++d\',\n\n             ts.r() = gs() /re[\'++d; if (*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:\'], ts.R() = gs() /re[\'++d; if (!*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:\'],\n\n             ts.i() = gs() /re[\'*--c = &&#{_}; goto **d++; #{_}:\'], ts.I() = \'goto **d++\', ts[\']\']() = \'goto **c++\', ts.m() = \'*d = malloc(*d)\', ts.M() = \'free(*d++)\',\n             ts.Y() = l[e = gs(), r = gs()] in \'*D++ = *d++; *--c = &&#{e}; #{r}: *--d = &&#{r}; goto *D[-1]; #{e}: --D\',\n\n             ts.l() = \'tmp = *d < *++d; *d = tmp\', ts.L() = \'tmp = *(f*)d < *(f*)++d; *d = tmp\', ts.k() = \'*--d = 0\', ts.K() = \'*--d = 1\', ts.t() = \'*--d = 2\', ts.T() = \'*--d = 3\',\n             ts.s() = \'*d = d[*d + 1]\', ts.S() = \'d[*d + 1] = *d; ++d\', ts.v() = \'*(f*)d = (f)*d\', ts.V() = \'*d = (e)*(f*)d\', ts.w() = \'tmp = *d; *d = d[1]; d[1] = tmp\',\n             ts.z() = gs() /re[\'tmp = *d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d = *--D\'],\n             ts.Z() = gs() /re[\'tmp = *d++; *D++=*d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d=*--D; *--d=*--D\'],\n\n             ts[\'.\']() = \'*--d = d[1]\', ts[\',\']() = \'++d\', ts[\'+\']() = \'d += *d\', ts[\'-\']() = \'d -= *d\', ts[\'@\']() = \'*--d = d\', ts[\'#\']() = \'d = *d\', ts[\'$\']() = \'*--d = c\',\n             ts[\'%\']() = \'c = *d++\', ts[\'?\']() = gs() /re[\'*--c = &&#{_}; goto **((d += 3) - 2 - !d[-1]); #{_}:\'], ts[\'/\']() = \'goto **((d += 3) - 2 - !d[-1])\',\n                                     ts[\'f\']() = gs() /re[\'d += 2; if (d[-1]) {*--c = #{_}; goto *d[-2];} #{_}:\'], ts[\'F\']() = \'d += 2; if (d[-1]) goto *d[-2];\'],\n\n           compile(n, code, opts) = l*[ns = seq[~[]], cs = seq[~[]], ss = seq[~[]], globals = {}, trace_for(opts, i, x) = opts.trace ? \'start("#{x}"); #{i}; trace\' : i,\n                                       encode(x) = bytecode_translations[x] /re[\'/* #{x} */ #{trace_for(opts, _ ? _() : "", x)}\'],\n                                       enter(n) = globals /se[cs.length && cs[cs.length - 1].push(\'/* [ */ *--d = &&#{n}\'), ns.push(n), cs.push([]), ss.push([])],\n                                       leave()  = globals /se[_[ns.pop()] = {generated: cs.pop() /se[_.push(encode(\']\'))], source: ss.pop().join(\'\')}],\n                                       c(i, cc) = code.charAt(i) /re[_ === \'[\' ? enter(gs()) /se[r()] : _ === \']\' ? r() /re[leave()] : cs[cs.length - 1].push(encode(_)) /se[r()],\n                                                                     where[r() = seq[ss *!s[s.push(_)]]]]\n                                                                 /re[i < code.length - 1 ? call/tail[c(i + 1, cc)] : cc(leave())]] in\n                                     call/cc[fn[cc][enter(n), call/tail[c(0, cc)]]]]});\n');