sdocp('caterwaul.hlasm.cpp.js.sdoc', 'C++ backend for high-level assembler | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis module exists to generate C++ from high-level assembly definitions. It wouldn\'t be used much in production; it\'s primarily useful for me to debug stuff (and in fact is the reference\nimplementation, but for it to be useful you have to disable GCC optimizations). Something useful may end up coming out of it though. If you let a Javascript program run in interpreted mode for\nsome time, you can take the collected traces and emit specialized code for them. It\'s theoretically possible to leverage this to generate performant C++ for a given Javascript workflow.\n\nTo support tail calls, the code generated by this backend is incredibly gnarly and bizarre. It should be reasonably fast though.\n\nInput data.\nThe format for incoming data is very simple. It\'s a hash from global name to bytecode or array of bytes. All we have to do is generate C++ to emulate the bytecode in the context of those\nglobals. Naturally the C++ generated by this backend is type-erased.\n\n  caterwaul.tconfiguration(\'std seq continuation\', \'hlasm.cpp\', function () {\n    this.namespace(\'hlasm\').cpp = translate,\n    where*[translate(globals, opts)  = l*[os       = opts || {},\n                                          derived  = seq[sp[globals] *[compile(_[0], _[1], os)] /[caterwaul.util.merge(_, _0)]], prelude = prerequisites(derived),\n                                          compiled = seq[~sk[derived].sort() *[[_, derived[_]]]\n                                                         -[[\'// Begin #{_[0]}: #{_[1].source.replace(/\\n/g, "")}\',\n                                                            \'#{_[0]}:\' + (os.trace ?\n                                                              \'fprintf(stderr, "\\\\n%s %d %s", "#{_[0]}", &&#{_[0]} - (long long)&main, "#{_[1].source.replace(/\\n/g, "")}");\' : \'\'),\n                                                            _[1].generated.join(\';\\n\') + \';\', \'// End #{_[0]}\\n\']]].join(\'\\n\')] in\n                                       prelude + \'\\n\\nint main() {\\n\\n#{main_setup(globals, os)}\\n\\n#{compiled}\\n}\',\n\n           gs                        = l[c = 0] in fn_[\'g#{++c}\'],\n           main_setup(globals, opts) = [\'e globals[] = {&&sleep_ms, &&pr_stacks, &&pr_float, &&pr_int, #{seq[(0 >>>[_ + 1] <<[_ < 99]) *["NULL"]].join(", ")}, &&write_c\' +\n                                        (opts.layout ? seq[~opts.layout.split(/\\s+/) *[\', &&\' + _]].join(\'\') : \'\') + \'};\',\n                                        \'e* gs = globals + 104;\', \'int i = 0;\', \'e *j = 0;\', \'*--c = &&exit;\', \'goto main;\',\n                                        \'exit: return *d;\', \'pr_int: printf("%d\\\\n", *d++); goto **c++;\', \'pr_float: printf("%f\\\\n", *d++); goto **c++;\',\n                                        \'pr_stacks:\',\n                                        \'fprintf(stderr, "\\\\n[data]\\\\n"); for(j = d; j < data + DATA_S; ++j) fprintf(stderr, "%4d|i%20lld|v%20lld|dv%20lf|V\\\\n", j - d, *j, *j - (e)(&main), *j);\',\n                                        \'fprintf(stderr, "[daux]\\\\n"); for(j = dtmp; j < D; ++j) fprintf(stderr, "%4d|i%20lld|v%20lld|dv%20lf|V\\\\n", j - dtmp, *j, *j - (e)(&main), *j);\',\n                                        \'fprintf(stderr, "[code]\\\\n"); for(j = c; j < code + CODE_S; ++j) fprintf(stderr, "%4d|i%20lld|dv\\\\n", j - c, *j - (e)(&main));\',\n                                        \'goto **c++;\',\n                                        \'sleep_ms: usleep(*d++ * 1000); goto **c++;\', \'std_call: (*(void(*)())d++)(); goto **c++;\', \'write_c: putc((char) *d++, stdout); goto **c++;\'].join(\'\\n\'),\n\n           prerequisites(globals)    = [\'#include<stdio.h>\', \'#include<unistd.h>\', \'#include<stdlib.h>\', \'\', \'#define DATA_S 1048576\', \'#define CODE_S 32768\',\n                                        \'#define start(x) fprintf(stderr, "\\\\n%8s", x)\',\n                                        \'#define trace fprintf(stderr, "%8d|x%8d|s%6d|c%20lld|v%20lld|dv%20lf|V", \' +\n                                                              \'D - dtmp, data + DATA_S - d, code + CODE_S - c, *d, *d - (long long)&main, *d)\',\n                                        \'\', \'typedef long long e;\', \'typedef double f;\', \'static e data[DATA_S];\', \'static e code[CODE_S];\', \'static e dtmp[DATA_S];\',\n                                        \'static e *d = data + DATA_S;\', \'static e *D = dtmp;\', \'static e *c = code + CODE_S;\', \'static e tmp;\'].join(\'\\n\'),\n\n           bytecode_translations     = {} /se.ts[\n             seq[~\'0123456789\' *![ts[_]() = \'*d *= 10; *d += #{_}\']], seq[sp[{a:\'+\', b:\'-\', c:\'*\', \'&\':\'&\', \'|\':\'|\', \'^\':\'^\'}] *![ts[_[0]]() = \'d[1] #{_[1]}= *d++\']],\n             ts.d() = \'tmp = d[0]; d[0] = d[1] % tmp, d[1] /= tmp\', seq[sp[{A:\'+\', B:\'-\', C:\'*\', D:\'/\'}] *![ts[_[0]]() = \'((f*)d)[1] #{_[1]}= *(f*)d++\']],\n             seq[sp[{n:\'-\', \'!\':\'!\', \'~\':\'~\'}] *![ts[_[0]]() = \'*d = #{_[1]}*d\']], ts.e() = \'++*d\', ts.E() = \'--*d\', ts.n() = \'*d = -*d\', ts.N() = \'*(*f)d = -*(*f)d\',\n             ts[\'<\']() = \'d[1] <<= *d++\', ts[\'>\']() = \'d[1] >>= *d++\', ts[\'_\']() = \'*--d = gs\', ts[\'*\']() = \'*d = *(e*)(*d)\', ts[\'=\']() = \'*(e*)*d = d[1]; ++d\',\n\n             ts.r() = gs() /re[\'++d; if (*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:\'], ts.R() = gs() /re[\'++d; if (!*d) {++d; *--c = #{_}; goto *d[-2];} #{_}:\'],\n\n             ts.m() = \'*(unsigned long long*)d = malloc(*d)\', ts.M() = \'free(*(unsigned long long*)d++)\',\n             ts.g() = gs() /re[\'*--c = &&#{_}; goto *gs[*d++]; #{_}:\'], ts.G() = \'goto *gs[*d++]\',\n             ts.i() = gs() /re[\'*--c = &&#{_}; goto **d++; #{_}:\'], ts.I() = \'goto **d++\', ts[\']\']() = \'goto **c++\', \n             ts.y() = l[e = gs(), r = gs()] in \'*D++ = *d++; *--c = &&#{e}; #{r}: *--d = &&#{r}; goto *D[-1]; #{e}: --D\',\n             ts.Y() = gs() /re[\'*D++ = *d++; *D++ = *d++; for (*D++ = 0; D[-1] < D[-3]; ++D[-1]) {*--c = &&#{_}; *--d = D[-1]; goto *D[-2]; #{_}:;} D -= 3\'],\n\n             ts.l() = \'tmp = *d < *++d; *d = tmp\', ts.L() = \'tmp = *(f*)d < *(f*)++d; *d = tmp\', ts.k() = \'*--d = 0\', ts.K() = \'*--d = 1\', ts.t() = \'*--d = 2\', ts.T() = \'*--d = 3\',\n             ts.s() = \'*d = d[*d + 1]\', ts.S() = \'d[*d] = d[1]; d += 2\', ts.v() = \'*(f*)d = (f)*d\', ts.V() = \'*d = (e)*(f*)d\', ts.w() = \'tmp = *d; *d = d[1]; d[1] = tmp\',\n             ts.z() = gs() /re[\'tmp = *d++; *D++=*d++; *--c = &&#{_}; goto *tmp; #{_}: *--d = *--D\'],\n             ts.Z() = gs() /re[\'d += 2; for (i = 0; i < d[-2]; ++i) *D++=d[i]; tmp=d[-1]; d += *D++=i; *--c = &&#{_}; goto *tmp; #{_}: for (i = *--D; i > 0; --i) *--d = *--D\'],\n\n             ts[\'.\']() = \'*--d = d[1]\', ts[\',\']() = \'++d\', ts[\'+\']() = \'d += *d + 1\', ts[\'-\']() = \'d -= *d - 1\', ts[\'@\']() = \'*--d = d\', ts[\'#\']() = \'d = *d\', ts[\'$\']() = \'*--d = c\',\n             ts[\'%\']() = \'c = *d++\', ts[\'?\']() = gs() /re[\'*--c = &&#{_}; goto **((d += 3) - 2 - !d[-1]); #{_}:\'], ts[\'/\']() = \'goto **((d += 3) - 2 - !d[-1])\',\n                                     ts[\'f\']() = gs() /re[\'d += 2; if (d[-1]) {*--c = #{_}; goto *d[-2];} #{_}:\'], ts[\'F\']() = \'d += 2; if (d[-1]) goto *d[-2]\'],\n\n           compile(n, code, opts) = l*[ns = seq[~[]], cs = seq[~[]], ss = seq[~[]], globals = {}, trace_for(opts, i, x) = opts.trace ? \'start("#{x}"); #{i}; trace\' : i,\n                                       encode(x) = bytecode_translations[x] /re[\'/* #{x} */ #{trace_for(opts, _ ? _() : "", x)}\'],\n                                       enter(n) = globals /se[cs.length && cs[cs.length - 1].push(\'/* [ */ *--d = &&#{n}\'), ns.push(n), cs.push([]), ss.push([])],\n                                       leave()  = globals /se[_[ns.pop()] = {generated: cs.pop() /se[_.push(encode(\']\'))], source: ss.pop().join(\'\')}],\n                                       c(i, cc) = code.charAt(i) /re[_ === \'[\' ? enter(gs()) /se[r()] : _ === \']\' ? r() /re[leave()] : cs[cs.length - 1].push(encode(_)) /se[r()],\n                                                                     where[r() = seq[ss *!s[s.push(_)]]]]\n                                                                 /re[i < code.length - 1 ? call/tail[c(i + 1, cc)] : cc(leave())]] in\n                                     call/cc[fn[cc][enter(n), call/tail[c(0, cc)]]]]});\n');