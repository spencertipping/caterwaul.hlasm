sdocp('caterwaul.hlasm.ia32.js.sdoc', 'IA-32 high-level assembler | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nBlock hints and alignment.\nx86 uses variable-length instructions and has instruction-decoding bottlenecks when jump targets aren\'t properly aligned. Normally the penalty doesn\'t justify taking special action, but hot\nblocks should be aligned to minimize problems. There are two ways that a block can be marked as hot. One is to simply let the program run and keep track of the block\'s execution count. At the\nnext recompilation cycle we then emit an optimized version of that block. The other way is to heuristically set the \'hot\' hint on the block. This is appropriate if we see a block inside an\ninner loop; for example:\n\n| for (var i = 0; ...) {\n    for (var j = 0; ...) {\n      // This block is almost certainly hot, so it should be aligned.\n    }\n  }\n\nBlock alignment inside a sequence isn\'t necessarily simple. There are a few different ways to do it, and some are faster than others. The obvious way is to just use an unconditional jump:\n\n| block_1:\n    ...\n    jmp .block_2\n    ; filler bytes\n  block_2:\n    ...\n\nHowever, this approach may not yield optimal results for performance purposes, especially if the extra space is due to compressed instruction encodings in the first place. (The consequence is\ntwofold: first, there\'s an extra jump; and second, there\'s potentially suboptimal instruction decoding.)\n\nAnother approach involves using nop instructions. This is workable but also has disadvantages; the nops themselves take execution time and contribute to decoding latency.\n\nThe most performant approach is to take advantage of the redundancy in some x86 instructions to find encodings that pack into the right decode patterns and block sizes. I believe this problem\nis NP however.\n');